"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Pool = void 0;
const events_1 = require("events");
const fs = require("fs");
const path = require("path");
const pg_1 = require("pg");
const uuid_1 = require("uuid");
class Pool extends events_1.EventEmitter {
    constructor(options) {
        // eslint-disable-next-line constructor-super
        super();
        this.connections = [];
        // Should self order by idle timeout ascending
        this.idleConnections = [];
        this.connectionQueue = [];
        this.isEnding = false;
        const defaultOptions = {
            poolSize: 10,
            idleTimeoutMillis: 10000,
            waitForAvailableConnectionTimeoutMillis: 90000,
            connectionTimeoutMillis: 30000,
            retryConnectionMaxRetries: 5,
            retryConnectionWaitMillis: 100,
            retryConnectionErrorCodes: ['ENOTFOUND', 'EAI_AGAIN'],
            reconnectOnDatabaseIsStartingError: true,
            waitForDatabaseStartupMillis: 0,
            databaseStartupTimeoutMillis: 90000,
            reconnectOnReadOnlyTransactionError: true,
            waitForReconnectReadOnlyTransactionMillis: 0,
            readOnlyTransactionReconnectTimeoutMillis: 90000,
            reconnectOnConnectionError: true,
            waitForReconnectConnectionMillis: 0,
            connectionReconnectTimeoutMillis: 90000,
            namedParameterFindRegExp: /@([\w])+\b/g,
            getNamedParameterReplaceRegExp(namedParameter) {
                // eslint-disable-next-line security/detect-non-literal-regexp
                return new RegExp(`@${namedParameter}\\b`, 'gm');
            },
            getNamedParameterName(namedParameterWithSymbols) {
                // Remove leading @ symbol
                return namedParameterWithSymbols.substring(1);
            },
        };
        const { ssl, ...otherOptions } = options;
        this.options = { ...defaultOptions, ...otherOptions };
        if (ssl === 'aws-rds') {
            this.options.ssl = {
                rejectUnauthorized: true,
                // eslint-disable-next-line security/detect-non-literal-fs-filename
                ca: fs.readFileSync(path.join(__dirname, './certs/rds-ca-2019-root.pem')),
                minVersion: 'TLSv1.2',
            };
        }
        else {
            this.options.ssl = ssl;
        }
        this.connectionQueueEventEmitter = new events_1.EventEmitter();
    }
    /**
     * Gets the number of queued requests waiting for a database connection
     */
    get waitingCount() {
        return this.connectionQueue.length;
    }
    /**
     * Gets the number of idle connections
     */
    get idleCount() {
        return this.idleConnections.length;
    }
    /**
     * Gets the total number of connections in the pool
     */
    get totalCount() {
        return this.connections.length;
    }
    /**
     * Gets a client connection from the pool.
     * Note: You must call `.release()` when finished with the client connection object. That will release the connection back to the pool to be used by other requests.
     */
    async connect() {
        if (this.isEnding) {
            throw new Error('Cannot use pool after calling end() on the pool');
        }
        const idleConnection = this.idleConnections.shift();
        if (idleConnection) {
            if (idleConnection.idleTimeoutTimer) {
                clearTimeout(idleConnection.idleTimeoutTimer);
            }
            this.emit('idleConnectionActivated');
            return idleConnection;
        }
        const id = uuid_1.v4();
        if (this.connections.length < this.options.poolSize) {
            this.connections.push(id);
            try {
                const connection = await this._createConnection(id);
                return connection;
            }
            catch (ex) {
                // Remove the connection id since we failed to connect
                const connectionIndex = this.connections.indexOf(id);
                if (connectionIndex > -1) {
                    this.connections.splice(connectionIndex, 1);
                }
                throw ex;
            }
        }
        this.emit('connectionRequestQueued');
        this.connectionQueue.push(id);
        let connectionTimeoutTimer = null;
        return (await Promise.race([
            new Promise((resolve) => {
                this.connectionQueueEventEmitter.on(`connection_${id}`, (client) => {
                    if (connectionTimeoutTimer) {
                        clearTimeout(connectionTimeoutTimer);
                    }
                    this.connectionQueueEventEmitter.removeAllListeners(`connection_${id}`);
                    this.emit('connectionRequestDequeued');
                    resolve(client);
                });
            }),
            // eslint-disable-next-line promise/param-names
            new Promise((_, reject) => {
                connectionTimeoutTimer = setTimeout(() => {
                    this.connectionQueueEventEmitter.removeAllListeners(`connection_${id}`);
                    // Remove this connection attempt from the connection queue
                    const index = this.connectionQueue.indexOf(id);
                    if (index > -1) {
                        this.connectionQueue.splice(index, 1);
                    }
                    reject(new Error('Timed out while waiting for available connection in pool'));
                }, this.options.waitForAvailableConnectionTimeoutMillis);
            }),
        ]));
    }
    /**
     * Gets a connection to the database and executes the specified query. This method will release the connection back to the pool when the query has finished.
     * @param {string} text
     * @param {object | object[]} values - If an object, keys represent named parameters in the query
     */
    query(text, values) {
        /* eslint-enable @typescript-eslint/no-explicit-any */
        if (!values || Array.isArray(values)) {
            return this._query(text, values);
        }
        // eslint-disable-next-line @typescript-eslint/prefer-regexp-exec
        const tokenMatches = text.match(this.options.namedParameterFindRegExp);
        if (!tokenMatches) {
            throw new Error('Did not find named parameters in in the query. Expected named parameter form is @foo');
        }
        // Get unique token names
        // https://stackoverflow.com/a/45886147/3085
        const tokens = Array.from(new Set(tokenMatches.map(this.options.getNamedParameterName)));
        const missingParameters = [];
        for (const token of tokens) {
            if (!(token in values)) {
                missingParameters.push(token);
            }
        }
        if (missingParameters.length) {
            throw new Error(`Missing query parameter(s): ${missingParameters.join(', ')}`);
        }
        let sql = text.slice();
        const params = [];
        let tokenIndex = 1;
        for (const token of tokens) {
            sql = sql.replace(this.options.getNamedParameterReplaceRegExp(token), `$${tokenIndex}`);
            params.push(values[token]);
            tokenIndex += 1;
        }
        return this._query(sql, params);
    }
    /**
     * Drains the pool of all active client connections. Used to shut down the pool down cleanly
     */
    end() {
        this.isEnding = true;
        return this._drainAllIdle();
    }
    async _drainAllIdle() {
        await Promise.all([...this.idleConnections].map((idleConnection) => this._removeConnection(idleConnection)));
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async _query(text, values, reconnectQueryStartTime) {
        const connection = await this.connect();
        let removeConnection = false;
        let timeoutError;
        let connectionError;
        try {
            const results = await connection.query(text, values);
            return results;
        }
        catch (ex) {
            const { message } = ex;
            if (this.options.reconnectOnReadOnlyTransactionError && /cannot execute [\s\w]+ in a read-only transaction/giu.test(message)) {
                timeoutError = ex;
                removeConnection = true;
            }
            else if (this.options.reconnectOnConnectionError && /Client has encountered a connection error and is not queryable/giu.test(message)) {
                connectionError = ex;
                removeConnection = true;
            }
            else {
                throw ex;
            }
        }
        finally {
            await connection.release(removeConnection);
        }
        // If we get here, that means that the query was attempted with a read-only connection.
        // This can happen when the cluster fails over to a read-replica
        if (timeoutError) {
            this.emit('queryDeniedForReadOnlyTransaction');
        }
        else if (connectionError) {
            // This can happen when a cluster fails over
            this.emit('queryDeniedForConnectionError');
        }
        // Clear all idle connections and try the query again with a fresh connection
        await this._drainAllIdle();
        if (!reconnectQueryStartTime) {
            // eslint-disable-next-line no-param-reassign
            reconnectQueryStartTime = process.hrtime();
        }
        if (timeoutError && this.options.waitForReconnectReadOnlyTransactionMillis > 0) {
            await new Promise((resolve) => {
                setTimeout(() => {
                    resolve();
                }, this.options.waitForReconnectReadOnlyTransactionMillis);
            });
        }
        if (connectionError && this.options.waitForReconnectConnectionMillis > 0) {
            await new Promise((resolve) => {
                setTimeout(() => {
                    resolve();
                }, this.options.waitForReconnectConnectionMillis);
            });
        }
        const diff = process.hrtime(reconnectQueryStartTime);
        const timeSinceLastRun = Number((diff[0] * 1e3 + diff[1] * 1e-6).toFixed(3));
        if (timeoutError && timeSinceLastRun > this.options.readOnlyTransactionReconnectTimeoutMillis) {
            throw timeoutError;
        }
        if (connectionError && timeSinceLastRun > this.options.connectionReconnectTimeoutMillis) {
            throw connectionError;
        }
        const results = await this._query(text, values, reconnectQueryStartTime);
        return results;
    }
    /**
     * Creates a new client connection to add to the pool
     * @param {string} connectionId
     * @param {number} [retryAttempt=0]
     * @param {bigint} [createConnectionStartTime] - High-resolution time (in nanoseconds) for when the connection was created
     * @param {[number,number]} [databaseStartupStartTime] - hrtime when the db was first listed as starting up
     */
    async _createConnection(connectionId, retryAttempt = 0, createConnectionStartTime = process.hrtime.bigint(), databaseStartupStartTime) {
        const client = new pg_1.Client(this.options);
        client.uniqueId = connectionId;
        /**
         * Releases the client connection back to the pool, to be used by another query.
         *
         * @param {boolean} [removeConnection=false]
         */
        client.release = async (removeConnection = false) => {
            if (this.isEnding || removeConnection) {
                await this._removeConnection(client);
                return;
            }
            const id = this.connectionQueue.shift();
            // Return the connection to be used by a queued request
            if (id) {
                this.connectionQueueEventEmitter.emit(`connection_${id}`, client);
            }
            else if (this.options.idleTimeoutMillis > 0) {
                client.idleTimeoutTimer = setTimeout(() => {
                    // eslint-disable-next-line no-void
                    void this._removeConnection(client);
                }, this.options.idleTimeoutMillis);
                this.idleConnections.push(client);
                this.emit('connectionIdle');
            }
            else {
                await this._removeConnection(client);
            }
        };
        client.errorHandler = (err) => {
            // fire and forget, we will always emit the error.
            // eslint-disable-next-line no-void
            void this._removeConnection(client).finally(() => this.emit('error', err, client));
        };
        client.on('error', client.errorHandler);
        let connectionTimeoutTimer = null;
        try {
            await Promise.race([
                (async function connectClient() {
                    try {
                        await client.connect();
                    }
                    finally {
                        if (connectionTimeoutTimer) {
                            clearTimeout(connectionTimeoutTimer);
                        }
                    }
                })(),
                // eslint-disable-next-line promise/param-names
                new Promise((_, reject) => {
                    connectionTimeoutTimer = setTimeout(() => {
                        reject(new Error('Timed out trying to connect to postgres'));
                    }, this.options.connectionTimeoutMillis);
                }),
            ]);
            this.emit('connectionAddedToPool', {
                connectionId,
                retryAttempt,
                startTime: createConnectionStartTime,
            });
        }
        catch (ex) {
            const { connection } = client;
            if (connection) {
                // Force a disconnect of the socket, if it exists.
                connection.stream.destroy();
            }
            await client.end();
            const { message, code } = ex;
            let retryConnection = false;
            if (this.options.retryConnectionMaxRetries) {
                if (code) {
                    retryConnection = this.options.retryConnectionErrorCodes.includes(code);
                }
                else {
                    for (const errorCode of this.options.retryConnectionErrorCodes) {
                        if (message.includes(errorCode)) {
                            retryConnection = true;
                            break;
                        }
                    }
                }
            }
            if (retryConnection && retryAttempt < this.options.retryConnectionMaxRetries) {
                this.emit('retryConnectionOnError');
                if (this.options.retryConnectionWaitMillis > 0) {
                    await new Promise((resolve) => {
                        setTimeout(() => {
                            resolve();
                        }, this.options.retryConnectionWaitMillis);
                    });
                }
                const connectionAfterRetry = await this._createConnection(connectionId, retryAttempt + 1, createConnectionStartTime, databaseStartupStartTime);
                return connectionAfterRetry;
            }
            if (this.options.reconnectOnDatabaseIsStartingError && /the database system is starting up/giu.test(message)) {
                this.emit('waitingForDatabaseToStart');
                if (!databaseStartupStartTime) {
                    // eslint-disable-next-line no-param-reassign
                    databaseStartupStartTime = process.hrtime();
                }
                if (this.options.waitForDatabaseStartupMillis > 0) {
                    await new Promise((resolve) => {
                        setTimeout(() => {
                            resolve();
                        }, this.options.waitForDatabaseStartupMillis);
                    });
                }
                const diff = process.hrtime(databaseStartupStartTime);
                const timeSinceFirstConnectAttempt = Number((diff[0] * 1e3 + diff[1] * 1e-6).toFixed(3));
                if (timeSinceFirstConnectAttempt > this.options.databaseStartupTimeoutMillis) {
                    throw ex;
                }
                const connectionAfterRetry = await this._createConnection(connectionId, 0, createConnectionStartTime, databaseStartupStartTime);
                return connectionAfterRetry;
            }
            throw ex;
        }
        return client;
    }
    /**
     * Removes the client connection from the pool and tries to gracefully shut it down
     * @param {PoolClient} client
     */
    async _removeConnection(client) {
        client.removeListener('error', client.errorHandler);
        // Ignore any errors when ending the connection
        client.on('error', () => {
            // NOOP
        });
        if (client.idleTimeoutTimer) {
            clearTimeout(client.idleTimeoutTimer);
        }
        const idleConnectionIndex = this.idleConnections.findIndex((connection) => connection.uniqueId === client.uniqueId);
        if (idleConnectionIndex > -1) {
            this.idleConnections.splice(idleConnectionIndex, 1);
            this.emit('connectionRemovedFromIdlePool');
        }
        const connectionIndex = this.connections.indexOf(client.uniqueId);
        if (connectionIndex > -1) {
            this.connections.splice(connectionIndex, 1);
        }
        try {
            await client.end();
        }
        catch (ex) {
            const { message } = ex;
            if (!/This socket has been ended by the other party/giu.test(message)) {
                this.emit('error', ex);
            }
        }
        this.emit('connectionRemovedFromPool');
    }
}
exports.Pool = Pool;
//# sourceMappingURL=index.js.map