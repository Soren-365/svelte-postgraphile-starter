"""The root query type which gives access points into the data universe."""
type Query implements Node {
  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form.
  """
  query: Query!

  """
  The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  """
  nodeId: ID!

  """Fetches an object given its globally unique `ID`."""
  node(
    """The globally unique `ID`."""
    nodeId: ID!
  ): Node

  """Reads and enables pagination through a set of `Administrator`."""
  administrators(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Administrator`."""
    orderBy: [AdministratorsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AdministratorCondition
  ): AdministratorsConnection

  """Reads and enables pagination through a set of `Citytable`."""
  citytables(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Citytable`."""
    orderBy: [CitytablesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CitytableCondition
  ): CitytablesConnection

  """Reads and enables pagination through a set of `ClassOnline`."""
  classOnlines(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `ClassOnline`."""
    orderBy: [ClassOnlinesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ClassOnlineCondition
  ): ClassOnlinesConnection

  """Reads and enables pagination through a set of `Classtable`."""
  classtables(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Classtable`."""
    orderBy: [ClasstablesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ClasstableCondition
  ): ClasstablesConnection

  """Reads and enables pagination through a set of `Classtype`."""
  classtypes(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Classtype`."""
    orderBy: [ClasstypesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ClasstypeCondition
  ): ClasstypesConnection

  """Reads and enables pagination through a set of `ContentAdmin`."""
  contentAdmins(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `ContentAdmin`."""
    orderBy: [ContentAdminsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ContentAdminCondition
  ): ContentAdminsConnection

  """Reads and enables pagination through a set of `Coupon`."""
  coupons(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Coupon`."""
    orderBy: [CouponsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CouponCondition
  ): CouponsConnection

  """Reads and enables pagination through a set of `Grouptable`."""
  grouptables(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Grouptable`."""
    orderBy: [GrouptablesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GrouptableCondition
  ): GrouptablesConnection

  """Reads and enables pagination through a set of `Student`."""
  students(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Student`."""
    orderBy: [StudentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StudentCondition
  ): StudentsConnection

  """Reads and enables pagination through a set of `StudentToClass`."""
  studentToClasses(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `StudentToClass`."""
    orderBy: [StudentToClassesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StudentToClassCondition
  ): StudentToClassesConnection

  """Reads and enables pagination through a set of `Teacher`."""
  teachers(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Teacher`."""
    orderBy: [TeachersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TeacherCondition
  ): TeachersConnection

  """Reads and enables pagination through a set of `Usertable`."""
  usertables(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Usertable`."""
    orderBy: [UsertablesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UsertableCondition
  ): UsertablesConnection
  administrator(id: Int!): Administrator
  citytable(id: Int!): Citytable
  classOnline(id: Int!): ClassOnline
  classtable(id: Int!): Classtable
  classtype(id: Int!): Classtype
  classtypeByType(type: String!): Classtype
  contentAdmin(id: Int!): ContentAdmin
  coupon(id: Int!): Coupon
  couponByCouponCode(couponCode: String!): Coupon
  grouptable(id: Int!): Grouptable
  student(id: Int!): Student
  studentToClass(studentId: Int!, classTypeId: Int!): StudentToClass
  teacher(id: Int!): Teacher
  usertableById(id: Int!): Usertable
  usertable(email: String!): Usertable
  arrayDiff(array1: String, array2: String): String

  """Reads a single `Administrator` using its globally unique `ID`."""
  administratorByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Administrator`.
    """
    nodeId: ID!
  ): Administrator

  """Reads a single `Citytable` using its globally unique `ID`."""
  citytableByNodeId(
    """The globally unique `ID` to be used in selecting a single `Citytable`."""
    nodeId: ID!
  ): Citytable

  """Reads a single `ClassOnline` using its globally unique `ID`."""
  classOnlineByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `ClassOnline`.
    """
    nodeId: ID!
  ): ClassOnline

  """Reads a single `Classtable` using its globally unique `ID`."""
  classtableByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Classtable`.
    """
    nodeId: ID!
  ): Classtable

  """Reads a single `Classtype` using its globally unique `ID`."""
  classtypeByNodeId(
    """The globally unique `ID` to be used in selecting a single `Classtype`."""
    nodeId: ID!
  ): Classtype

  """Reads a single `ContentAdmin` using its globally unique `ID`."""
  contentAdminByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `ContentAdmin`.
    """
    nodeId: ID!
  ): ContentAdmin

  """Reads a single `Coupon` using its globally unique `ID`."""
  couponByNodeId(
    """The globally unique `ID` to be used in selecting a single `Coupon`."""
    nodeId: ID!
  ): Coupon

  """Reads a single `Grouptable` using its globally unique `ID`."""
  grouptableByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Grouptable`.
    """
    nodeId: ID!
  ): Grouptable

  """Reads a single `Student` using its globally unique `ID`."""
  studentByNodeId(
    """The globally unique `ID` to be used in selecting a single `Student`."""
    nodeId: ID!
  ): Student

  """Reads a single `StudentToClass` using its globally unique `ID`."""
  studentToClassByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `StudentToClass`.
    """
    nodeId: ID!
  ): StudentToClass

  """Reads a single `Teacher` using its globally unique `ID`."""
  teacherByNodeId(
    """The globally unique `ID` to be used in selecting a single `Teacher`."""
    nodeId: ID!
  ): Teacher

  """Reads a single `Usertable` using its globally unique `ID`."""
  usertableByNodeId(
    """The globally unique `ID` to be used in selecting a single `Usertable`."""
    nodeId: ID!
  ): Usertable
}

"""An object with a globally unique `ID`."""
interface Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

"""A connection to a list of `Administrator` values."""
type AdministratorsConnection {
  """A list of `Administrator` objects."""
  nodes: [Administrator!]!

  """
  A list of edges which contains the `Administrator` and cursor to aid in pagination.
  """
  edges: [AdministratorsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Administrator` you could get from the connection."""
  totalCount: Int!
}

type Administrator implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  presentedName: String
  userId: Int
  emailForNotifications: String
  myRole: Roles
  lastModified: Datetime
  timeCreated: Datetime

  """Reads a single `Usertable` that is related to this `Administrator`."""
  user: Usertable
}

enum Roles {
  STUDENT
  TEACHER
  APP_ADMIN
  SUPERVISOR
  CONTENT_ADMIN
}

"""
A point in time as described by the [ISO
8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
"""
scalar Datetime

type Usertable implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  name: String
  email: String!
  password: String!
  telephone: String
  yogaYear: Int
  gender: Genders
  cityId: Int
  signupInClassId: Int
  signupInClassTypeId: Int
  isAdministrator: Boolean
  isTeacher: Boolean
  myRole: Roles
  lastModified: Datetime
  timeCreated: Datetime

  """Reads a single `Citytable` that is related to this `Usertable`."""
  city: Citytable

  """Reads a single `Classtable` that is related to this `Usertable`."""
  signupInClass: Classtable

  """Reads and enables pagination through a set of `Student`."""
  studentsByUserId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Student`."""
    orderBy: [StudentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StudentCondition
  ): StudentsConnection!

  """Reads and enables pagination through a set of `Teacher`."""
  teachersByUserId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Teacher`."""
    orderBy: [TeachersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TeacherCondition
  ): TeachersConnection!

  """Reads and enables pagination through a set of `Administrator`."""
  administratorsByUserId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Administrator`."""
    orderBy: [AdministratorsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AdministratorCondition
  ): AdministratorsConnection!

  """Reads and enables pagination through a set of `ContentAdmin`."""
  contentAdminsByUserId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `ContentAdmin`."""
    orderBy: [ContentAdminsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ContentAdminCondition
  ): ContentAdminsConnection!
}

enum Genders {
  MAN
  WOMAN
}

type Citytable implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  city: String

  """Reads and enables pagination through a set of `Usertable`."""
  usertablesByCityId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Usertable`."""
    orderBy: [UsertablesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UsertableCondition
  ): UsertablesConnection!

  """Reads and enables pagination through a set of `Classtable`."""
  classtablesByCityId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Classtable`."""
    orderBy: [ClasstablesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ClasstableCondition
  ): ClasstablesConnection!

  """Reads and enables pagination through a set of `Student`."""
  studentsByCityId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Student`."""
    orderBy: [StudentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StudentCondition
  ): StudentsConnection!

  """Reads and enables pagination through a set of `Coupon`."""
  couponsByCityId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Coupon`."""
    orderBy: [CouponsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CouponCondition
  ): CouponsConnection!

  """Reads and enables pagination through a set of `Teacher`."""
  teachersByHomeCityId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Teacher`."""
    orderBy: [TeachersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TeacherCondition
  ): TeachersConnection!
}

"""A connection to a list of `Usertable` values."""
type UsertablesConnection {
  """A list of `Usertable` objects."""
  nodes: [Usertable!]!

  """
  A list of edges which contains the `Usertable` and cursor to aid in pagination.
  """
  edges: [UsertablesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Usertable` you could get from the connection."""
  totalCount: Int!
}

"""A `Usertable` edge in the connection."""
type UsertablesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Usertable` at the end of the edge."""
  node: Usertable!
}

"""A location in a connection that can be used for resuming pagination."""
scalar Cursor

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor

  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}

"""Methods to use when ordering `Usertable`."""
enum UsertablesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  EMAIL_ASC
  EMAIL_DESC
  CITY_ID_ASC
  CITY_ID_DESC
  SIGNUP_IN_CLASS_ID_ASC
  SIGNUP_IN_CLASS_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Usertable` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input UsertableCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `email` field."""
  email: String

  """Checks for equality with the object’s `cityId` field."""
  cityId: Int

  """Checks for equality with the object’s `signupInClassId` field."""
  signupInClassId: Int
}

"""A connection to a list of `Classtable` values."""
type ClasstablesConnection {
  """A list of `Classtable` objects."""
  nodes: [Classtable!]!

  """
  A list of edges which contains the `Classtable` and cursor to aid in pagination.
  """
  edges: [ClasstablesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Classtable` you could get from the connection."""
  totalCount: Int!
}

type Classtable implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  birthDatetime: Datetime
  updatedDatetime: Datetime
  durationInverval: Interval
  year: Int
  weekDay: String
  startTime: String
  duration: String
  address: String
  typeId: Int
  teacherId: Int
  cityId: Int
  tempTeachersId: [Int]
  studentsId: [Int]
  lastModified: Datetime
  timeCreated: Datetime

  """Reads a single `Classtype` that is related to this `Classtable`."""
  type: Classtype

  """Reads a single `Teacher` that is related to this `Classtable`."""
  teacher: Teacher

  """Reads a single `Citytable` that is related to this `Classtable`."""
  city: Citytable

  """Reads and enables pagination through a set of `Usertable`."""
  usertablesBySignupInClassId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Usertable`."""
    orderBy: [UsertablesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UsertableCondition
  ): UsertablesConnection!

  """Reads and enables pagination through a set of `ClassOnline`."""
  classOnlines(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `ClassOnline`."""
    orderBy: [ClassOnlinesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ClassOnlineCondition
  ): ClassOnlinesConnection!

  """Reads and enables pagination through a set of `StudentToClass`."""
  studentToClassesByClassId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `StudentToClass`."""
    orderBy: [StudentToClassesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StudentToClassCondition
  ): StudentToClassesConnection!

  """Reads and enables pagination through a set of `Coupon`."""
  couponsByClassId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Coupon`."""
    orderBy: [CouponsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CouponCondition
  ): CouponsConnection!

  """Reads and enables pagination through a set of `Teacher`."""
  teachersByClassId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Teacher`."""
    orderBy: [TeachersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TeacherCondition
  ): TeachersConnection!
}

"""
An interval of time that has passed where the smallest distinct unit is a second.
"""
type Interval {
  """
  A quantity of seconds. This is the only non-integer field, as all the other
  fields will dump their overflow into a smaller unit of time. Intervals don’t
  have a smaller unit than seconds.
  """
  seconds: Float

  """A quantity of minutes."""
  minutes: Int

  """A quantity of hours."""
  hours: Int

  """A quantity of days."""
  days: Int

  """A quantity of months."""
  months: Int

  """A quantity of years."""
  years: Int
}

type Classtype implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  type: String

  """Reads and enables pagination through a set of `Grouptable`."""
  grouptablesByTypeId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Grouptable`."""
    orderBy: [GrouptablesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GrouptableCondition
  ): GrouptablesConnection!

  """Reads and enables pagination through a set of `Classtable`."""
  classtablesByTypeId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Classtable`."""
    orderBy: [ClasstablesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ClasstableCondition
  ): ClasstablesConnection!

  """Reads and enables pagination through a set of `StudentToClass`."""
  studentToClassesByClassTypeId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `StudentToClass`."""
    orderBy: [StudentToClassesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StudentToClassCondition
  ): StudentToClassesConnection!

  """Reads and enables pagination through a set of `Teacher`."""
  teachersByMainClassTypeId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Teacher`."""
    orderBy: [TeachersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TeacherCondition
  ): TeachersConnection!
}

"""A connection to a list of `Grouptable` values."""
type GrouptablesConnection {
  """A list of `Grouptable` objects."""
  nodes: [Grouptable!]!

  """
  A list of edges which contains the `Grouptable` and cursor to aid in pagination.
  """
  edges: [GrouptablesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Grouptable` you could get from the connection."""
  totalCount: Int!
}

type Grouptable implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  birthDatetime: Datetime
  year: Int
  typeId: Int
  lastmodified: Datetime
  timecreated: Datetime

  """Reads a single `Classtype` that is related to this `Grouptable`."""
  type: Classtype

  """Reads and enables pagination through a set of `Coupon`."""
  couponsByGroupId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Coupon`."""
    orderBy: [CouponsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CouponCondition
  ): CouponsConnection!
}

"""A connection to a list of `Coupon` values."""
type CouponsConnection {
  """A list of `Coupon` objects."""
  nodes: [Coupon!]!

  """
  A list of edges which contains the `Coupon` and cursor to aid in pagination.
  """
  edges: [CouponsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Coupon` you could get from the connection."""
  totalCount: Int!
}

type Coupon implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  couponCode: String!
  email: String
  groupId: Int
  classId: Int
  classTypeId: Int!
  teacherId: Int
  cityId: Int
  gender: Genders
  couponType: CouponType
  signedUp: Boolean
  invited: Boolean
  lastModified: Datetime
  timecreated: Datetime

  """Reads a single `Grouptable` that is related to this `Coupon`."""
  group: Grouptable

  """Reads a single `Classtable` that is related to this `Coupon`."""
  class: Classtable

  """Reads a single `Teacher` that is related to this `Coupon`."""
  teacher: Teacher

  """Reads a single `Citytable` that is related to this `Coupon`."""
  city: Citytable
}

enum CouponType {
  TEACHER
  STUDENT
  ADMINISTRATOR
}

type Teacher implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  presentedName: String
  userId: Int
  yogaYear: Int
  classId: Int
  homeCityId: Int
  gender: Genders
  mainClassTypeId: Int
  teachingClassIds: [Int]
  tempTeachingClassIds: [Int]
  emailForNotifications: String
  lastModified: Datetime
  timeCreated: Datetime

  """Reads a single `Usertable` that is related to this `Teacher`."""
  user: Usertable

  """Reads a single `Classtable` that is related to this `Teacher`."""
  class: Classtable

  """Reads a single `Citytable` that is related to this `Teacher`."""
  homeCity: Citytable

  """Reads a single `Classtype` that is related to this `Teacher`."""
  mainClassType: Classtype

  """Reads and enables pagination through a set of `Classtable`."""
  classtables(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Classtable`."""
    orderBy: [ClasstablesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ClasstableCondition
  ): ClasstablesConnection!

  """Reads and enables pagination through a set of `Coupon`."""
  coupons(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Coupon`."""
    orderBy: [CouponsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CouponCondition
  ): CouponsConnection!
}

"""Methods to use when ordering `Classtable`."""
enum ClasstablesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  TYPE_ID_ASC
  TYPE_ID_DESC
  TEACHER_ID_ASC
  TEACHER_ID_DESC
  CITY_ID_ASC
  CITY_ID_DESC
  TEMP_TEACHERS_ID_ASC
  TEMP_TEACHERS_ID_DESC
  STUDENTS_ID_ASC
  STUDENTS_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Classtable` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input ClasstableCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `typeId` field."""
  typeId: Int

  """Checks for equality with the object’s `teacherId` field."""
  teacherId: Int

  """Checks for equality with the object’s `cityId` field."""
  cityId: Int

  """Checks for equality with the object’s `tempTeachersId` field."""
  tempTeachersId: [Int]

  """Checks for equality with the object’s `studentsId` field."""
  studentsId: [Int]
}

"""Methods to use when ordering `Coupon`."""
enum CouponsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  COUPON_CODE_ASC
  COUPON_CODE_DESC
  GROUP_ID_ASC
  GROUP_ID_DESC
  CLASS_ID_ASC
  CLASS_ID_DESC
  TEACHER_ID_ASC
  TEACHER_ID_DESC
  CITY_ID_ASC
  CITY_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Coupon` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input CouponCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `couponCode` field."""
  couponCode: String

  """Checks for equality with the object’s `groupId` field."""
  groupId: Int

  """Checks for equality with the object’s `classId` field."""
  classId: Int

  """Checks for equality with the object’s `teacherId` field."""
  teacherId: Int

  """Checks for equality with the object’s `cityId` field."""
  cityId: Int
}

"""A `Coupon` edge in the connection."""
type CouponsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Coupon` at the end of the edge."""
  node: Coupon!
}

"""A `Grouptable` edge in the connection."""
type GrouptablesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Grouptable` at the end of the edge."""
  node: Grouptable!
}

"""Methods to use when ordering `Grouptable`."""
enum GrouptablesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  TYPE_ID_ASC
  TYPE_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Grouptable` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input GrouptableCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `typeId` field."""
  typeId: Int
}

"""A connection to a list of `StudentToClass` values."""
type StudentToClassesConnection {
  """A list of `StudentToClass` objects."""
  nodes: [StudentToClass!]!

  """
  A list of edges which contains the `StudentToClass` and cursor to aid in pagination.
  """
  edges: [StudentToClassesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `StudentToClass` you could get from the connection."""
  totalCount: Int!
}

type StudentToClass implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  studentId: Int!
  classId: Int!
  classTypeId: Int!

  """Reads a single `Student` that is related to this `StudentToClass`."""
  student: Student

  """Reads a single `Classtable` that is related to this `StudentToClass`."""
  class: Classtable

  """Reads a single `Classtype` that is related to this `StudentToClass`."""
  classType: Classtype
}

type Student implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  presentedName: String
  userId: Int
  yogaYear: Int
  gender: Genders
  cityId: Int
  email: String
  lastModified: Datetime
  timeCreated: Datetime

  """Reads a single `Usertable` that is related to this `Student`."""
  user: Usertable

  """Reads a single `Citytable` that is related to this `Student`."""
  city: Citytable

  """Reads and enables pagination through a set of `StudentToClass`."""
  studentToClasses(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `StudentToClass`."""
    orderBy: [StudentToClassesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StudentToClassCondition
  ): StudentToClassesConnection!
}

"""Methods to use when ordering `StudentToClass`."""
enum StudentToClassesOrderBy {
  NATURAL
  STUDENT_ID_ASC
  STUDENT_ID_DESC
  CLASS_ID_ASC
  CLASS_ID_DESC
  CLASS_TYPE_ID_ASC
  CLASS_TYPE_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `StudentToClass` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input StudentToClassCondition {
  """Checks for equality with the object’s `studentId` field."""
  studentId: Int

  """Checks for equality with the object’s `classId` field."""
  classId: Int

  """Checks for equality with the object’s `classTypeId` field."""
  classTypeId: Int
}

"""A `StudentToClass` edge in the connection."""
type StudentToClassesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `StudentToClass` at the end of the edge."""
  node: StudentToClass!
}

"""A connection to a list of `Teacher` values."""
type TeachersConnection {
  """A list of `Teacher` objects."""
  nodes: [Teacher!]!

  """
  A list of edges which contains the `Teacher` and cursor to aid in pagination.
  """
  edges: [TeachersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Teacher` you could get from the connection."""
  totalCount: Int!
}

"""A `Teacher` edge in the connection."""
type TeachersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Teacher` at the end of the edge."""
  node: Teacher!
}

"""Methods to use when ordering `Teacher`."""
enum TeachersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  CLASS_ID_ASC
  CLASS_ID_DESC
  HOME_CITY_ID_ASC
  HOME_CITY_ID_DESC
  MAIN_CLASS_TYPE_ID_ASC
  MAIN_CLASS_TYPE_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Teacher` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input TeacherCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `userId` field."""
  userId: Int

  """Checks for equality with the object’s `classId` field."""
  classId: Int

  """Checks for equality with the object’s `homeCityId` field."""
  homeCityId: Int

  """Checks for equality with the object’s `mainClassTypeId` field."""
  mainClassTypeId: Int
}

"""A connection to a list of `ClassOnline` values."""
type ClassOnlinesConnection {
  """A list of `ClassOnline` objects."""
  nodes: [ClassOnline!]!

  """
  A list of edges which contains the `ClassOnline` and cursor to aid in pagination.
  """
  edges: [ClassOnlinesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `ClassOnline` you could get from the connection."""
  totalCount: Int!
}

type ClassOnline implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  classtableId: Int
  theoryDbLink: String
  mainTheoryStartTime: Time
  mainTheoryDuration: Interval
  secondaryTheoryStartTime: Time
  secondaryTheoryDuration: Interval
  practiceStartTime: Time
  practiceDuration: Interval
  practiceProgram: String
  practiceProgramAudioLink: String
  lastModified: Datetime
  timeCreated: Datetime

  """Reads a single `Classtable` that is related to this `ClassOnline`."""
  classtable: Classtable
}

"""
The exact time of day, does not include the date. May or may not have a timezone offset.
"""
scalar Time

"""A `ClassOnline` edge in the connection."""
type ClassOnlinesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `ClassOnline` at the end of the edge."""
  node: ClassOnline!
}

"""Methods to use when ordering `ClassOnline`."""
enum ClassOnlinesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CLASSTABLE_ID_ASC
  CLASSTABLE_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `ClassOnline` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input ClassOnlineCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `classtableId` field."""
  classtableId: Int
}

"""A `Classtable` edge in the connection."""
type ClasstablesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Classtable` at the end of the edge."""
  node: Classtable!
}

"""A connection to a list of `Student` values."""
type StudentsConnection {
  """A list of `Student` objects."""
  nodes: [Student!]!

  """
  A list of edges which contains the `Student` and cursor to aid in pagination.
  """
  edges: [StudentsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Student` you could get from the connection."""
  totalCount: Int!
}

"""A `Student` edge in the connection."""
type StudentsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Student` at the end of the edge."""
  node: Student!
}

"""Methods to use when ordering `Student`."""
enum StudentsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  CITY_ID_ASC
  CITY_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Student` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input StudentCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `userId` field."""
  userId: Int

  """Checks for equality with the object’s `cityId` field."""
  cityId: Int
}

"""Methods to use when ordering `Administrator`."""
enum AdministratorsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Administrator` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input AdministratorCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `userId` field."""
  userId: Int
}

"""A connection to a list of `ContentAdmin` values."""
type ContentAdminsConnection {
  """A list of `ContentAdmin` objects."""
  nodes: [ContentAdmin!]!

  """
  A list of edges which contains the `ContentAdmin` and cursor to aid in pagination.
  """
  edges: [ContentAdminsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `ContentAdmin` you could get from the connection."""
  totalCount: Int!
}

type ContentAdmin implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  presentedName: String
  userId: Int
  emailForNotifications: String
  lastModified: Datetime
  timeCreated: Datetime

  """Reads a single `Usertable` that is related to this `ContentAdmin`."""
  user: Usertable
}

"""A `ContentAdmin` edge in the connection."""
type ContentAdminsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `ContentAdmin` at the end of the edge."""
  node: ContentAdmin!
}

"""Methods to use when ordering `ContentAdmin`."""
enum ContentAdminsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `ContentAdmin` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input ContentAdminCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `userId` field."""
  userId: Int
}

"""A `Administrator` edge in the connection."""
type AdministratorsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Administrator` at the end of the edge."""
  node: Administrator!
}

"""A connection to a list of `Citytable` values."""
type CitytablesConnection {
  """A list of `Citytable` objects."""
  nodes: [Citytable!]!

  """
  A list of edges which contains the `Citytable` and cursor to aid in pagination.
  """
  edges: [CitytablesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Citytable` you could get from the connection."""
  totalCount: Int!
}

"""A `Citytable` edge in the connection."""
type CitytablesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Citytable` at the end of the edge."""
  node: Citytable!
}

"""Methods to use when ordering `Citytable`."""
enum CitytablesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CITY_ASC
  CITY_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Citytable` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input CitytableCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `city` field."""
  city: String
}

"""A connection to a list of `Classtype` values."""
type ClasstypesConnection {
  """A list of `Classtype` objects."""
  nodes: [Classtype!]!

  """
  A list of edges which contains the `Classtype` and cursor to aid in pagination.
  """
  edges: [ClasstypesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Classtype` you could get from the connection."""
  totalCount: Int!
}

"""A `Classtype` edge in the connection."""
type ClasstypesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Classtype` at the end of the edge."""
  node: Classtype!
}

"""Methods to use when ordering `Classtype`."""
enum ClasstypesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  TYPE_ASC
  TYPE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Classtype` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input ClasstypeCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `type` field."""
  type: String
}

"""
The root mutation type which contains root level fields which mutate data.
"""
type Mutation {
  """Creates a single `Administrator`."""
  createAdministrator(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateAdministratorInput!
  ): CreateAdministratorPayload

  """Creates a single `Citytable`."""
  createCitytable(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCitytableInput!
  ): CreateCitytablePayload

  """Creates a single `ClassOnline`."""
  createClassOnline(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateClassOnlineInput!
  ): CreateClassOnlinePayload

  """Creates a single `Classtable`."""
  createClasstable(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateClasstableInput!
  ): CreateClasstablePayload

  """Creates a single `Classtype`."""
  createClasstype(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateClasstypeInput!
  ): CreateClasstypePayload

  """Creates a single `ContentAdmin`."""
  createContentAdmin(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateContentAdminInput!
  ): CreateContentAdminPayload

  """Creates a single `Coupon`."""
  createCoupon(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCouponInput!
  ): CreateCouponPayload

  """Creates a single `Grouptable`."""
  createGrouptable(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateGrouptableInput!
  ): CreateGrouptablePayload

  """Creates a single `Student`."""
  createStudent(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateStudentInput!
  ): CreateStudentPayload

  """Creates a single `StudentToClass`."""
  createStudentToClass(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateStudentToClassInput!
  ): CreateStudentToClassPayload

  """Creates a single `Teacher`."""
  createTeacher(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateTeacherInput!
  ): CreateTeacherPayload

  """Creates a single `Usertable`."""
  createUsertable(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateUsertableInput!
  ): CreateUsertablePayload

  """
  Updates a single `Administrator` using its globally unique id and a patch.
  """
  updateAdministratorByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAdministratorByNodeIdInput!
  ): UpdateAdministratorPayload

  """Updates a single `Administrator` using a unique key and a patch."""
  updateAdministrator(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAdministratorInput!
  ): UpdateAdministratorPayload

  """Updates a single `Citytable` using its globally unique id and a patch."""
  updateCitytableByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCitytableByNodeIdInput!
  ): UpdateCitytablePayload

  """Updates a single `Citytable` using a unique key and a patch."""
  updateCitytable(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCitytableInput!
  ): UpdateCitytablePayload

  """
  Updates a single `ClassOnline` using its globally unique id and a patch.
  """
  updateClassOnlineByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateClassOnlineByNodeIdInput!
  ): UpdateClassOnlinePayload

  """Updates a single `ClassOnline` using a unique key and a patch."""
  updateClassOnline(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateClassOnlineInput!
  ): UpdateClassOnlinePayload

  """
  Updates a single `Classtable` using its globally unique id and a patch.
  """
  updateClasstableByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateClasstableByNodeIdInput!
  ): UpdateClasstablePayload

  """Updates a single `Classtable` using a unique key and a patch."""
  updateClasstable(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateClasstableInput!
  ): UpdateClasstablePayload

  """Updates a single `Classtype` using its globally unique id and a patch."""
  updateClasstypeByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateClasstypeByNodeIdInput!
  ): UpdateClasstypePayload

  """Updates a single `Classtype` using a unique key and a patch."""
  updateClasstype(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateClasstypeInput!
  ): UpdateClasstypePayload

  """Updates a single `Classtype` using a unique key and a patch."""
  updateClasstypeByType(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateClasstypeByTypeInput!
  ): UpdateClasstypePayload

  """
  Updates a single `ContentAdmin` using its globally unique id and a patch.
  """
  updateContentAdminByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateContentAdminByNodeIdInput!
  ): UpdateContentAdminPayload

  """Updates a single `ContentAdmin` using a unique key and a patch."""
  updateContentAdmin(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateContentAdminInput!
  ): UpdateContentAdminPayload

  """Updates a single `Coupon` using its globally unique id and a patch."""
  updateCouponByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCouponByNodeIdInput!
  ): UpdateCouponPayload

  """Updates a single `Coupon` using a unique key and a patch."""
  updateCoupon(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCouponInput!
  ): UpdateCouponPayload

  """Updates a single `Coupon` using a unique key and a patch."""
  updateCouponByCouponCode(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCouponByCouponCodeInput!
  ): UpdateCouponPayload

  """
  Updates a single `Grouptable` using its globally unique id and a patch.
  """
  updateGrouptableByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateGrouptableByNodeIdInput!
  ): UpdateGrouptablePayload

  """Updates a single `Grouptable` using a unique key and a patch."""
  updateGrouptable(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateGrouptableInput!
  ): UpdateGrouptablePayload

  """Updates a single `Student` using its globally unique id and a patch."""
  updateStudentByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateStudentByNodeIdInput!
  ): UpdateStudentPayload

  """Updates a single `Student` using a unique key and a patch."""
  updateStudent(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateStudentInput!
  ): UpdateStudentPayload

  """
  Updates a single `StudentToClass` using its globally unique id and a patch.
  """
  updateStudentToClassByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateStudentToClassByNodeIdInput!
  ): UpdateStudentToClassPayload

  """Updates a single `StudentToClass` using a unique key and a patch."""
  updateStudentToClass(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateStudentToClassInput!
  ): UpdateStudentToClassPayload

  """Updates a single `Teacher` using its globally unique id and a patch."""
  updateTeacherByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTeacherByNodeIdInput!
  ): UpdateTeacherPayload

  """Updates a single `Teacher` using a unique key and a patch."""
  updateTeacher(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTeacherInput!
  ): UpdateTeacherPayload

  """Updates a single `Usertable` using its globally unique id and a patch."""
  updateUsertableByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUsertableByNodeIdInput!
  ): UpdateUsertablePayload

  """Updates a single `Usertable` using a unique key and a patch."""
  updateUsertableById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUsertableByIdInput!
  ): UpdateUsertablePayload

  """Updates a single `Usertable` using a unique key and a patch."""
  updateUsertable(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUsertableInput!
  ): UpdateUsertablePayload

  """Deletes a single `Administrator` using its globally unique id."""
  deleteAdministratorByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAdministratorByNodeIdInput!
  ): DeleteAdministratorPayload

  """Deletes a single `Administrator` using a unique key."""
  deleteAdministrator(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAdministratorInput!
  ): DeleteAdministratorPayload

  """Deletes a single `Citytable` using its globally unique id."""
  deleteCitytableByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCitytableByNodeIdInput!
  ): DeleteCitytablePayload

  """Deletes a single `Citytable` using a unique key."""
  deleteCitytable(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCitytableInput!
  ): DeleteCitytablePayload

  """Deletes a single `ClassOnline` using its globally unique id."""
  deleteClassOnlineByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteClassOnlineByNodeIdInput!
  ): DeleteClassOnlinePayload

  """Deletes a single `ClassOnline` using a unique key."""
  deleteClassOnline(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteClassOnlineInput!
  ): DeleteClassOnlinePayload

  """Deletes a single `Classtable` using its globally unique id."""
  deleteClasstableByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteClasstableByNodeIdInput!
  ): DeleteClasstablePayload

  """Deletes a single `Classtable` using a unique key."""
  deleteClasstable(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteClasstableInput!
  ): DeleteClasstablePayload

  """Deletes a single `Classtype` using its globally unique id."""
  deleteClasstypeByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteClasstypeByNodeIdInput!
  ): DeleteClasstypePayload

  """Deletes a single `Classtype` using a unique key."""
  deleteClasstype(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteClasstypeInput!
  ): DeleteClasstypePayload

  """Deletes a single `Classtype` using a unique key."""
  deleteClasstypeByType(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteClasstypeByTypeInput!
  ): DeleteClasstypePayload

  """Deletes a single `ContentAdmin` using its globally unique id."""
  deleteContentAdminByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteContentAdminByNodeIdInput!
  ): DeleteContentAdminPayload

  """Deletes a single `ContentAdmin` using a unique key."""
  deleteContentAdmin(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteContentAdminInput!
  ): DeleteContentAdminPayload

  """Deletes a single `Coupon` using its globally unique id."""
  deleteCouponByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCouponByNodeIdInput!
  ): DeleteCouponPayload

  """Deletes a single `Coupon` using a unique key."""
  deleteCoupon(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCouponInput!
  ): DeleteCouponPayload

  """Deletes a single `Coupon` using a unique key."""
  deleteCouponByCouponCode(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCouponByCouponCodeInput!
  ): DeleteCouponPayload

  """Deletes a single `Grouptable` using its globally unique id."""
  deleteGrouptableByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteGrouptableByNodeIdInput!
  ): DeleteGrouptablePayload

  """Deletes a single `Grouptable` using a unique key."""
  deleteGrouptable(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteGrouptableInput!
  ): DeleteGrouptablePayload

  """Deletes a single `Student` using its globally unique id."""
  deleteStudentByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteStudentByNodeIdInput!
  ): DeleteStudentPayload

  """Deletes a single `Student` using a unique key."""
  deleteStudent(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteStudentInput!
  ): DeleteStudentPayload

  """Deletes a single `StudentToClass` using its globally unique id."""
  deleteStudentToClassByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteStudentToClassByNodeIdInput!
  ): DeleteStudentToClassPayload

  """Deletes a single `StudentToClass` using a unique key."""
  deleteStudentToClass(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteStudentToClassInput!
  ): DeleteStudentToClassPayload

  """Deletes a single `Teacher` using its globally unique id."""
  deleteTeacherByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTeacherByNodeIdInput!
  ): DeleteTeacherPayload

  """Deletes a single `Teacher` using a unique key."""
  deleteTeacher(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTeacherInput!
  ): DeleteTeacherPayload

  """Deletes a single `Usertable` using its globally unique id."""
  deleteUsertableByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUsertableByNodeIdInput!
  ): DeleteUsertablePayload

  """Deletes a single `Usertable` using a unique key."""
  deleteUsertableById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUsertableByIdInput!
  ): DeleteUsertablePayload

  """Deletes a single `Usertable` using a unique key."""
  deleteUsertable(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUsertableInput!
  ): DeleteUsertablePayload
  getClassesByIds(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: GetClassesByIdsInput!
  ): GetClassesByIdsPayload
  testfunc(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: TestfuncInput!
  ): TestfuncPayload
  updateYear(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateYearInput!
  ): UpdateYearPayload
}

"""The output of our create `Administrator` mutation."""
type CreateAdministratorPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Administrator` that was created by this mutation."""
  administrator: Administrator

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Usertable` that is related to this `Administrator`."""
  user: Usertable

  """An edge for our `Administrator`. May be used by Relay 1."""
  administratorEdge(
    """The method to use when ordering `Administrator`."""
    orderBy: [AdministratorsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdministratorsEdge
}

"""All input for the create `Administrator` mutation."""
input CreateAdministratorInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Administrator` to be created by this mutation."""
  administrator: AdministratorInput!
}

"""An input for mutations affecting `Administrator`"""
input AdministratorInput {
  id: Int
  presentedName: String
  userId: Int
  emailForNotifications: String
  myRole: Roles
  lastModified: Datetime
  timeCreated: Datetime
}

"""The output of our create `Citytable` mutation."""
type CreateCitytablePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Citytable` that was created by this mutation."""
  citytable: Citytable

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Citytable`. May be used by Relay 1."""
  citytableEdge(
    """The method to use when ordering `Citytable`."""
    orderBy: [CitytablesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CitytablesEdge
}

"""All input for the create `Citytable` mutation."""
input CreateCitytableInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Citytable` to be created by this mutation."""
  citytable: CitytableInput!
}

"""An input for mutations affecting `Citytable`"""
input CitytableInput {
  id: Int
  city: String
}

"""The output of our create `ClassOnline` mutation."""
type CreateClassOnlinePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ClassOnline` that was created by this mutation."""
  classOnline: ClassOnline

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Classtable` that is related to this `ClassOnline`."""
  classtable: Classtable

  """An edge for our `ClassOnline`. May be used by Relay 1."""
  classOnlineEdge(
    """The method to use when ordering `ClassOnline`."""
    orderBy: [ClassOnlinesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ClassOnlinesEdge
}

"""All input for the create `ClassOnline` mutation."""
input CreateClassOnlineInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `ClassOnline` to be created by this mutation."""
  classOnline: ClassOnlineInput!
}

"""An input for mutations affecting `ClassOnline`"""
input ClassOnlineInput {
  id: Int
  classtableId: Int
  theoryDbLink: String
  mainTheoryStartTime: Time
  mainTheoryDuration: IntervalInput
  secondaryTheoryStartTime: Time
  secondaryTheoryDuration: IntervalInput
  practiceStartTime: Time
  practiceDuration: IntervalInput
  practiceProgram: String
  practiceProgramAudioLink: String
  lastModified: Datetime
  timeCreated: Datetime
}

"""
An interval of time that has passed where the smallest distinct unit is a second.
"""
input IntervalInput {
  """
  A quantity of seconds. This is the only non-integer field, as all the other
  fields will dump their overflow into a smaller unit of time. Intervals don’t
  have a smaller unit than seconds.
  """
  seconds: Float

  """A quantity of minutes."""
  minutes: Int

  """A quantity of hours."""
  hours: Int

  """A quantity of days."""
  days: Int

  """A quantity of months."""
  months: Int

  """A quantity of years."""
  years: Int
}

"""The output of our create `Classtable` mutation."""
type CreateClasstablePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Classtable` that was created by this mutation."""
  classtable: Classtable

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Classtype` that is related to this `Classtable`."""
  type: Classtype

  """Reads a single `Teacher` that is related to this `Classtable`."""
  teacher: Teacher

  """Reads a single `Citytable` that is related to this `Classtable`."""
  city: Citytable

  """An edge for our `Classtable`. May be used by Relay 1."""
  classtableEdge(
    """The method to use when ordering `Classtable`."""
    orderBy: [ClasstablesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ClasstablesEdge
}

"""All input for the create `Classtable` mutation."""
input CreateClasstableInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Classtable` to be created by this mutation."""
  classtable: ClasstableInput!
}

"""An input for mutations affecting `Classtable`"""
input ClasstableInput {
  id: Int
  birthDatetime: Datetime
  updatedDatetime: Datetime
  durationInverval: IntervalInput
  year: Int
  weekDay: String
  startTime: String
  duration: String
  address: String
  typeId: Int
  teacherId: Int
  cityId: Int
  tempTeachersId: [Int]
  studentsId: [Int]
  lastModified: Datetime
  timeCreated: Datetime
}

"""The output of our create `Classtype` mutation."""
type CreateClasstypePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Classtype` that was created by this mutation."""
  classtype: Classtype

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Classtype`. May be used by Relay 1."""
  classtypeEdge(
    """The method to use when ordering `Classtype`."""
    orderBy: [ClasstypesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ClasstypesEdge
}

"""All input for the create `Classtype` mutation."""
input CreateClasstypeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Classtype` to be created by this mutation."""
  classtype: ClasstypeInput!
}

"""An input for mutations affecting `Classtype`"""
input ClasstypeInput {
  id: Int
  type: String
}

"""The output of our create `ContentAdmin` mutation."""
type CreateContentAdminPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ContentAdmin` that was created by this mutation."""
  contentAdmin: ContentAdmin

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Usertable` that is related to this `ContentAdmin`."""
  user: Usertable

  """An edge for our `ContentAdmin`. May be used by Relay 1."""
  contentAdminEdge(
    """The method to use when ordering `ContentAdmin`."""
    orderBy: [ContentAdminsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ContentAdminsEdge
}

"""All input for the create `ContentAdmin` mutation."""
input CreateContentAdminInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `ContentAdmin` to be created by this mutation."""
  contentAdmin: ContentAdminInput!
}

"""An input for mutations affecting `ContentAdmin`"""
input ContentAdminInput {
  id: Int
  presentedName: String
  userId: Int
  emailForNotifications: String
  lastModified: Datetime
  timeCreated: Datetime
}

"""The output of our create `Coupon` mutation."""
type CreateCouponPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Coupon` that was created by this mutation."""
  coupon: Coupon

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Grouptable` that is related to this `Coupon`."""
  group: Grouptable

  """Reads a single `Classtable` that is related to this `Coupon`."""
  class: Classtable

  """Reads a single `Teacher` that is related to this `Coupon`."""
  teacher: Teacher

  """Reads a single `Citytable` that is related to this `Coupon`."""
  city: Citytable

  """An edge for our `Coupon`. May be used by Relay 1."""
  couponEdge(
    """The method to use when ordering `Coupon`."""
    orderBy: [CouponsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CouponsEdge
}

"""All input for the create `Coupon` mutation."""
input CreateCouponInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Coupon` to be created by this mutation."""
  coupon: CouponInput!
}

"""An input for mutations affecting `Coupon`"""
input CouponInput {
  id: Int
  couponCode: String!
  email: String
  groupId: Int
  classId: Int
  classTypeId: Int!
  teacherId: Int
  cityId: Int
  gender: Genders
  couponType: CouponType
  signedUp: Boolean
  invited: Boolean
  lastModified: Datetime
  timecreated: Datetime
}

"""The output of our create `Grouptable` mutation."""
type CreateGrouptablePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Grouptable` that was created by this mutation."""
  grouptable: Grouptable

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Classtype` that is related to this `Grouptable`."""
  type: Classtype

  """An edge for our `Grouptable`. May be used by Relay 1."""
  grouptableEdge(
    """The method to use when ordering `Grouptable`."""
    orderBy: [GrouptablesOrderBy!] = [PRIMARY_KEY_ASC]
  ): GrouptablesEdge
}

"""All input for the create `Grouptable` mutation."""
input CreateGrouptableInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Grouptable` to be created by this mutation."""
  grouptable: GrouptableInput!
}

"""An input for mutations affecting `Grouptable`"""
input GrouptableInput {
  id: Int
  birthDatetime: Datetime
  year: Int
  typeId: Int
  lastmodified: Datetime
  timecreated: Datetime
}

"""The output of our create `Student` mutation."""
type CreateStudentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Student` that was created by this mutation."""
  student: Student

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Usertable` that is related to this `Student`."""
  user: Usertable

  """Reads a single `Citytable` that is related to this `Student`."""
  city: Citytable

  """An edge for our `Student`. May be used by Relay 1."""
  studentEdge(
    """The method to use when ordering `Student`."""
    orderBy: [StudentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): StudentsEdge
}

"""All input for the create `Student` mutation."""
input CreateStudentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Student` to be created by this mutation."""
  student: StudentInput!
}

"""An input for mutations affecting `Student`"""
input StudentInput {
  id: Int
  presentedName: String
  userId: Int
  yogaYear: Int
  gender: Genders
  cityId: Int
  email: String
  lastModified: Datetime
  timeCreated: Datetime
}

"""The output of our create `StudentToClass` mutation."""
type CreateStudentToClassPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `StudentToClass` that was created by this mutation."""
  studentToClass: StudentToClass

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Student` that is related to this `StudentToClass`."""
  student: Student

  """Reads a single `Classtable` that is related to this `StudentToClass`."""
  class: Classtable

  """Reads a single `Classtype` that is related to this `StudentToClass`."""
  classType: Classtype

  """An edge for our `StudentToClass`. May be used by Relay 1."""
  studentToClassEdge(
    """The method to use when ordering `StudentToClass`."""
    orderBy: [StudentToClassesOrderBy!] = [PRIMARY_KEY_ASC]
  ): StudentToClassesEdge
}

"""All input for the create `StudentToClass` mutation."""
input CreateStudentToClassInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `StudentToClass` to be created by this mutation."""
  studentToClass: StudentToClassInput!
}

"""An input for mutations affecting `StudentToClass`"""
input StudentToClassInput {
  studentId: Int!
  classId: Int!
  classTypeId: Int!
}

"""The output of our create `Teacher` mutation."""
type CreateTeacherPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Teacher` that was created by this mutation."""
  teacher: Teacher

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Usertable` that is related to this `Teacher`."""
  user: Usertable

  """Reads a single `Classtable` that is related to this `Teacher`."""
  class: Classtable

  """Reads a single `Citytable` that is related to this `Teacher`."""
  homeCity: Citytable

  """Reads a single `Classtype` that is related to this `Teacher`."""
  mainClassType: Classtype

  """An edge for our `Teacher`. May be used by Relay 1."""
  teacherEdge(
    """The method to use when ordering `Teacher`."""
    orderBy: [TeachersOrderBy!] = [PRIMARY_KEY_ASC]
  ): TeachersEdge
}

"""All input for the create `Teacher` mutation."""
input CreateTeacherInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Teacher` to be created by this mutation."""
  teacher: TeacherInput!
}

"""An input for mutations affecting `Teacher`"""
input TeacherInput {
  id: Int
  presentedName: String
  userId: Int
  yogaYear: Int
  classId: Int
  homeCityId: Int
  gender: Genders
  mainClassTypeId: Int
  teachingClassIds: [Int]
  tempTeachingClassIds: [Int]
  emailForNotifications: String
  lastModified: Datetime
  timeCreated: Datetime
}

"""The output of our create `Usertable` mutation."""
type CreateUsertablePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Usertable` that was created by this mutation."""
  usertable: Usertable

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Citytable` that is related to this `Usertable`."""
  city: Citytable

  """Reads a single `Classtable` that is related to this `Usertable`."""
  signupInClass: Classtable

  """An edge for our `Usertable`. May be used by Relay 1."""
  usertableEdge(
    """The method to use when ordering `Usertable`."""
    orderBy: [UsertablesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsertablesEdge
}

"""All input for the create `Usertable` mutation."""
input CreateUsertableInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Usertable` to be created by this mutation."""
  usertable: UsertableInput!
}

"""An input for mutations affecting `Usertable`"""
input UsertableInput {
  id: Int
  name: String
  email: String!
  password: String!
  telephone: String
  yogaYear: Int
  gender: Genders
  cityId: Int
  signupInClassId: Int
  signupInClassTypeId: Int
  isAdministrator: Boolean
  isTeacher: Boolean
  myRole: Roles
  lastModified: Datetime
  timeCreated: Datetime
}

"""The output of our update `Administrator` mutation."""
type UpdateAdministratorPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Administrator` that was updated by this mutation."""
  administrator: Administrator

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Usertable` that is related to this `Administrator`."""
  user: Usertable

  """An edge for our `Administrator`. May be used by Relay 1."""
  administratorEdge(
    """The method to use when ordering `Administrator`."""
    orderBy: [AdministratorsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdministratorsEdge
}

"""All input for the `updateAdministratorByNodeId` mutation."""
input UpdateAdministratorByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Administrator` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Administrator` being updated.
  """
  patch: AdministratorPatch!
}

"""
Represents an update to a `Administrator`. Fields that are set will be updated.
"""
input AdministratorPatch {
  id: Int
  presentedName: String
  userId: Int
  emailForNotifications: String
  myRole: Roles
  lastModified: Datetime
  timeCreated: Datetime
}

"""All input for the `updateAdministrator` mutation."""
input UpdateAdministratorInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Administrator` being updated.
  """
  patch: AdministratorPatch!
  id: Int!
}

"""The output of our update `Citytable` mutation."""
type UpdateCitytablePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Citytable` that was updated by this mutation."""
  citytable: Citytable

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Citytable`. May be used by Relay 1."""
  citytableEdge(
    """The method to use when ordering `Citytable`."""
    orderBy: [CitytablesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CitytablesEdge
}

"""All input for the `updateCitytableByNodeId` mutation."""
input UpdateCitytableByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Citytable` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Citytable` being updated.
  """
  patch: CitytablePatch!
}

"""
Represents an update to a `Citytable`. Fields that are set will be updated.
"""
input CitytablePatch {
  id: Int
  city: String
}

"""All input for the `updateCitytable` mutation."""
input UpdateCitytableInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Citytable` being updated.
  """
  patch: CitytablePatch!
  id: Int!
}

"""The output of our update `ClassOnline` mutation."""
type UpdateClassOnlinePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ClassOnline` that was updated by this mutation."""
  classOnline: ClassOnline

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Classtable` that is related to this `ClassOnline`."""
  classtable: Classtable

  """An edge for our `ClassOnline`. May be used by Relay 1."""
  classOnlineEdge(
    """The method to use when ordering `ClassOnline`."""
    orderBy: [ClassOnlinesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ClassOnlinesEdge
}

"""All input for the `updateClassOnlineByNodeId` mutation."""
input UpdateClassOnlineByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ClassOnline` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `ClassOnline` being updated.
  """
  patch: ClassOnlinePatch!
}

"""
Represents an update to a `ClassOnline`. Fields that are set will be updated.
"""
input ClassOnlinePatch {
  id: Int
  classtableId: Int
  theoryDbLink: String
  mainTheoryStartTime: Time
  mainTheoryDuration: IntervalInput
  secondaryTheoryStartTime: Time
  secondaryTheoryDuration: IntervalInput
  practiceStartTime: Time
  practiceDuration: IntervalInput
  practiceProgram: String
  practiceProgramAudioLink: String
  lastModified: Datetime
  timeCreated: Datetime
}

"""All input for the `updateClassOnline` mutation."""
input UpdateClassOnlineInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `ClassOnline` being updated.
  """
  patch: ClassOnlinePatch!
  id: Int!
}

"""The output of our update `Classtable` mutation."""
type UpdateClasstablePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Classtable` that was updated by this mutation."""
  classtable: Classtable

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Classtype` that is related to this `Classtable`."""
  type: Classtype

  """Reads a single `Teacher` that is related to this `Classtable`."""
  teacher: Teacher

  """Reads a single `Citytable` that is related to this `Classtable`."""
  city: Citytable

  """An edge for our `Classtable`. May be used by Relay 1."""
  classtableEdge(
    """The method to use when ordering `Classtable`."""
    orderBy: [ClasstablesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ClasstablesEdge
}

"""All input for the `updateClasstableByNodeId` mutation."""
input UpdateClasstableByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Classtable` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Classtable` being updated.
  """
  patch: ClasstablePatch!
}

"""
Represents an update to a `Classtable`. Fields that are set will be updated.
"""
input ClasstablePatch {
  id: Int
  birthDatetime: Datetime
  updatedDatetime: Datetime
  durationInverval: IntervalInput
  year: Int
  weekDay: String
  startTime: String
  duration: String
  address: String
  typeId: Int
  teacherId: Int
  cityId: Int
  tempTeachersId: [Int]
  studentsId: [Int]
  lastModified: Datetime
  timeCreated: Datetime
}

"""All input for the `updateClasstable` mutation."""
input UpdateClasstableInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Classtable` being updated.
  """
  patch: ClasstablePatch!
  id: Int!
}

"""The output of our update `Classtype` mutation."""
type UpdateClasstypePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Classtype` that was updated by this mutation."""
  classtype: Classtype

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Classtype`. May be used by Relay 1."""
  classtypeEdge(
    """The method to use when ordering `Classtype`."""
    orderBy: [ClasstypesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ClasstypesEdge
}

"""All input for the `updateClasstypeByNodeId` mutation."""
input UpdateClasstypeByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Classtype` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Classtype` being updated.
  """
  patch: ClasstypePatch!
}

"""
Represents an update to a `Classtype`. Fields that are set will be updated.
"""
input ClasstypePatch {
  id: Int
  type: String
}

"""All input for the `updateClasstype` mutation."""
input UpdateClasstypeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Classtype` being updated.
  """
  patch: ClasstypePatch!
  id: Int!
}

"""All input for the `updateClasstypeByType` mutation."""
input UpdateClasstypeByTypeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Classtype` being updated.
  """
  patch: ClasstypePatch!
  type: String!
}

"""The output of our update `ContentAdmin` mutation."""
type UpdateContentAdminPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ContentAdmin` that was updated by this mutation."""
  contentAdmin: ContentAdmin

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Usertable` that is related to this `ContentAdmin`."""
  user: Usertable

  """An edge for our `ContentAdmin`. May be used by Relay 1."""
  contentAdminEdge(
    """The method to use when ordering `ContentAdmin`."""
    orderBy: [ContentAdminsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ContentAdminsEdge
}

"""All input for the `updateContentAdminByNodeId` mutation."""
input UpdateContentAdminByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ContentAdmin` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `ContentAdmin` being updated.
  """
  patch: ContentAdminPatch!
}

"""
Represents an update to a `ContentAdmin`. Fields that are set will be updated.
"""
input ContentAdminPatch {
  id: Int
  presentedName: String
  userId: Int
  emailForNotifications: String
  lastModified: Datetime
  timeCreated: Datetime
}

"""All input for the `updateContentAdmin` mutation."""
input UpdateContentAdminInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `ContentAdmin` being updated.
  """
  patch: ContentAdminPatch!
  id: Int!
}

"""The output of our update `Coupon` mutation."""
type UpdateCouponPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Coupon` that was updated by this mutation."""
  coupon: Coupon

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Grouptable` that is related to this `Coupon`."""
  group: Grouptable

  """Reads a single `Classtable` that is related to this `Coupon`."""
  class: Classtable

  """Reads a single `Teacher` that is related to this `Coupon`."""
  teacher: Teacher

  """Reads a single `Citytable` that is related to this `Coupon`."""
  city: Citytable

  """An edge for our `Coupon`. May be used by Relay 1."""
  couponEdge(
    """The method to use when ordering `Coupon`."""
    orderBy: [CouponsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CouponsEdge
}

"""All input for the `updateCouponByNodeId` mutation."""
input UpdateCouponByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Coupon` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Coupon` being updated.
  """
  patch: CouponPatch!
}

"""
Represents an update to a `Coupon`. Fields that are set will be updated.
"""
input CouponPatch {
  id: Int
  couponCode: String
  email: String
  groupId: Int
  classId: Int
  classTypeId: Int
  teacherId: Int
  cityId: Int
  gender: Genders
  couponType: CouponType
  signedUp: Boolean
  invited: Boolean
  lastModified: Datetime
  timecreated: Datetime
}

"""All input for the `updateCoupon` mutation."""
input UpdateCouponInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Coupon` being updated.
  """
  patch: CouponPatch!
  id: Int!
}

"""All input for the `updateCouponByCouponCode` mutation."""
input UpdateCouponByCouponCodeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Coupon` being updated.
  """
  patch: CouponPatch!
  couponCode: String!
}

"""The output of our update `Grouptable` mutation."""
type UpdateGrouptablePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Grouptable` that was updated by this mutation."""
  grouptable: Grouptable

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Classtype` that is related to this `Grouptable`."""
  type: Classtype

  """An edge for our `Grouptable`. May be used by Relay 1."""
  grouptableEdge(
    """The method to use when ordering `Grouptable`."""
    orderBy: [GrouptablesOrderBy!] = [PRIMARY_KEY_ASC]
  ): GrouptablesEdge
}

"""All input for the `updateGrouptableByNodeId` mutation."""
input UpdateGrouptableByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Grouptable` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Grouptable` being updated.
  """
  patch: GrouptablePatch!
}

"""
Represents an update to a `Grouptable`. Fields that are set will be updated.
"""
input GrouptablePatch {
  id: Int
  birthDatetime: Datetime
  year: Int
  typeId: Int
  lastmodified: Datetime
  timecreated: Datetime
}

"""All input for the `updateGrouptable` mutation."""
input UpdateGrouptableInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Grouptable` being updated.
  """
  patch: GrouptablePatch!
  id: Int!
}

"""The output of our update `Student` mutation."""
type UpdateStudentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Student` that was updated by this mutation."""
  student: Student

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Usertable` that is related to this `Student`."""
  user: Usertable

  """Reads a single `Citytable` that is related to this `Student`."""
  city: Citytable

  """An edge for our `Student`. May be used by Relay 1."""
  studentEdge(
    """The method to use when ordering `Student`."""
    orderBy: [StudentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): StudentsEdge
}

"""All input for the `updateStudentByNodeId` mutation."""
input UpdateStudentByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Student` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Student` being updated.
  """
  patch: StudentPatch!
}

"""
Represents an update to a `Student`. Fields that are set will be updated.
"""
input StudentPatch {
  id: Int
  presentedName: String
  userId: Int
  yogaYear: Int
  gender: Genders
  cityId: Int
  email: String
  lastModified: Datetime
  timeCreated: Datetime
}

"""All input for the `updateStudent` mutation."""
input UpdateStudentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Student` being updated.
  """
  patch: StudentPatch!
  id: Int!
}

"""The output of our update `StudentToClass` mutation."""
type UpdateStudentToClassPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `StudentToClass` that was updated by this mutation."""
  studentToClass: StudentToClass

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Student` that is related to this `StudentToClass`."""
  student: Student

  """Reads a single `Classtable` that is related to this `StudentToClass`."""
  class: Classtable

  """Reads a single `Classtype` that is related to this `StudentToClass`."""
  classType: Classtype

  """An edge for our `StudentToClass`. May be used by Relay 1."""
  studentToClassEdge(
    """The method to use when ordering `StudentToClass`."""
    orderBy: [StudentToClassesOrderBy!] = [PRIMARY_KEY_ASC]
  ): StudentToClassesEdge
}

"""All input for the `updateStudentToClassByNodeId` mutation."""
input UpdateStudentToClassByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `StudentToClass` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `StudentToClass` being updated.
  """
  patch: StudentToClassPatch!
}

"""
Represents an update to a `StudentToClass`. Fields that are set will be updated.
"""
input StudentToClassPatch {
  studentId: Int
  classId: Int
  classTypeId: Int
}

"""All input for the `updateStudentToClass` mutation."""
input UpdateStudentToClassInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `StudentToClass` being updated.
  """
  patch: StudentToClassPatch!
  studentId: Int!
  classTypeId: Int!
}

"""The output of our update `Teacher` mutation."""
type UpdateTeacherPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Teacher` that was updated by this mutation."""
  teacher: Teacher

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Usertable` that is related to this `Teacher`."""
  user: Usertable

  """Reads a single `Classtable` that is related to this `Teacher`."""
  class: Classtable

  """Reads a single `Citytable` that is related to this `Teacher`."""
  homeCity: Citytable

  """Reads a single `Classtype` that is related to this `Teacher`."""
  mainClassType: Classtype

  """An edge for our `Teacher`. May be used by Relay 1."""
  teacherEdge(
    """The method to use when ordering `Teacher`."""
    orderBy: [TeachersOrderBy!] = [PRIMARY_KEY_ASC]
  ): TeachersEdge
}

"""All input for the `updateTeacherByNodeId` mutation."""
input UpdateTeacherByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Teacher` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Teacher` being updated.
  """
  patch: TeacherPatch!
}

"""
Represents an update to a `Teacher`. Fields that are set will be updated.
"""
input TeacherPatch {
  id: Int
  presentedName: String
  userId: Int
  yogaYear: Int
  classId: Int
  homeCityId: Int
  gender: Genders
  mainClassTypeId: Int
  teachingClassIds: [Int]
  tempTeachingClassIds: [Int]
  emailForNotifications: String
  lastModified: Datetime
  timeCreated: Datetime
}

"""All input for the `updateTeacher` mutation."""
input UpdateTeacherInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Teacher` being updated.
  """
  patch: TeacherPatch!
  id: Int!
}

"""The output of our update `Usertable` mutation."""
type UpdateUsertablePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Usertable` that was updated by this mutation."""
  usertable: Usertable

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Citytable` that is related to this `Usertable`."""
  city: Citytable

  """Reads a single `Classtable` that is related to this `Usertable`."""
  signupInClass: Classtable

  """An edge for our `Usertable`. May be used by Relay 1."""
  usertableEdge(
    """The method to use when ordering `Usertable`."""
    orderBy: [UsertablesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsertablesEdge
}

"""All input for the `updateUsertableByNodeId` mutation."""
input UpdateUsertableByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Usertable` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Usertable` being updated.
  """
  patch: UsertablePatch!
}

"""
Represents an update to a `Usertable`. Fields that are set will be updated.
"""
input UsertablePatch {
  id: Int
  name: String
  email: String
  password: String
  telephone: String
  yogaYear: Int
  gender: Genders
  cityId: Int
  signupInClassId: Int
  signupInClassTypeId: Int
  isAdministrator: Boolean
  isTeacher: Boolean
  myRole: Roles
  lastModified: Datetime
  timeCreated: Datetime
}

"""All input for the `updateUsertableById` mutation."""
input UpdateUsertableByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Usertable` being updated.
  """
  patch: UsertablePatch!
  id: Int!
}

"""All input for the `updateUsertable` mutation."""
input UpdateUsertableInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Usertable` being updated.
  """
  patch: UsertablePatch!
  email: String!
}

"""The output of our delete `Administrator` mutation."""
type DeleteAdministratorPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Administrator` that was deleted by this mutation."""
  administrator: Administrator
  deletedAdministratorNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Usertable` that is related to this `Administrator`."""
  user: Usertable

  """An edge for our `Administrator`. May be used by Relay 1."""
  administratorEdge(
    """The method to use when ordering `Administrator`."""
    orderBy: [AdministratorsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdministratorsEdge
}

"""All input for the `deleteAdministratorByNodeId` mutation."""
input DeleteAdministratorByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Administrator` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteAdministrator` mutation."""
input DeleteAdministratorInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Citytable` mutation."""
type DeleteCitytablePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Citytable` that was deleted by this mutation."""
  citytable: Citytable
  deletedCitytableNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Citytable`. May be used by Relay 1."""
  citytableEdge(
    """The method to use when ordering `Citytable`."""
    orderBy: [CitytablesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CitytablesEdge
}

"""All input for the `deleteCitytableByNodeId` mutation."""
input DeleteCitytableByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Citytable` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteCitytable` mutation."""
input DeleteCitytableInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `ClassOnline` mutation."""
type DeleteClassOnlinePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ClassOnline` that was deleted by this mutation."""
  classOnline: ClassOnline
  deletedClassOnlineNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Classtable` that is related to this `ClassOnline`."""
  classtable: Classtable

  """An edge for our `ClassOnline`. May be used by Relay 1."""
  classOnlineEdge(
    """The method to use when ordering `ClassOnline`."""
    orderBy: [ClassOnlinesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ClassOnlinesEdge
}

"""All input for the `deleteClassOnlineByNodeId` mutation."""
input DeleteClassOnlineByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ClassOnline` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteClassOnline` mutation."""
input DeleteClassOnlineInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Classtable` mutation."""
type DeleteClasstablePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Classtable` that was deleted by this mutation."""
  classtable: Classtable
  deletedClasstableNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Classtype` that is related to this `Classtable`."""
  type: Classtype

  """Reads a single `Teacher` that is related to this `Classtable`."""
  teacher: Teacher

  """Reads a single `Citytable` that is related to this `Classtable`."""
  city: Citytable

  """An edge for our `Classtable`. May be used by Relay 1."""
  classtableEdge(
    """The method to use when ordering `Classtable`."""
    orderBy: [ClasstablesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ClasstablesEdge
}

"""All input for the `deleteClasstableByNodeId` mutation."""
input DeleteClasstableByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Classtable` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteClasstable` mutation."""
input DeleteClasstableInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Classtype` mutation."""
type DeleteClasstypePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Classtype` that was deleted by this mutation."""
  classtype: Classtype
  deletedClasstypeNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Classtype`. May be used by Relay 1."""
  classtypeEdge(
    """The method to use when ordering `Classtype`."""
    orderBy: [ClasstypesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ClasstypesEdge
}

"""All input for the `deleteClasstypeByNodeId` mutation."""
input DeleteClasstypeByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Classtype` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteClasstype` mutation."""
input DeleteClasstypeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""All input for the `deleteClasstypeByType` mutation."""
input DeleteClasstypeByTypeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  type: String!
}

"""The output of our delete `ContentAdmin` mutation."""
type DeleteContentAdminPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ContentAdmin` that was deleted by this mutation."""
  contentAdmin: ContentAdmin
  deletedContentAdminNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Usertable` that is related to this `ContentAdmin`."""
  user: Usertable

  """An edge for our `ContentAdmin`. May be used by Relay 1."""
  contentAdminEdge(
    """The method to use when ordering `ContentAdmin`."""
    orderBy: [ContentAdminsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ContentAdminsEdge
}

"""All input for the `deleteContentAdminByNodeId` mutation."""
input DeleteContentAdminByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ContentAdmin` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteContentAdmin` mutation."""
input DeleteContentAdminInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Coupon` mutation."""
type DeleteCouponPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Coupon` that was deleted by this mutation."""
  coupon: Coupon
  deletedCouponNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Grouptable` that is related to this `Coupon`."""
  group: Grouptable

  """Reads a single `Classtable` that is related to this `Coupon`."""
  class: Classtable

  """Reads a single `Teacher` that is related to this `Coupon`."""
  teacher: Teacher

  """Reads a single `Citytable` that is related to this `Coupon`."""
  city: Citytable

  """An edge for our `Coupon`. May be used by Relay 1."""
  couponEdge(
    """The method to use when ordering `Coupon`."""
    orderBy: [CouponsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CouponsEdge
}

"""All input for the `deleteCouponByNodeId` mutation."""
input DeleteCouponByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Coupon` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteCoupon` mutation."""
input DeleteCouponInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""All input for the `deleteCouponByCouponCode` mutation."""
input DeleteCouponByCouponCodeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  couponCode: String!
}

"""The output of our delete `Grouptable` mutation."""
type DeleteGrouptablePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Grouptable` that was deleted by this mutation."""
  grouptable: Grouptable
  deletedGrouptableNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Classtype` that is related to this `Grouptable`."""
  type: Classtype

  """An edge for our `Grouptable`. May be used by Relay 1."""
  grouptableEdge(
    """The method to use when ordering `Grouptable`."""
    orderBy: [GrouptablesOrderBy!] = [PRIMARY_KEY_ASC]
  ): GrouptablesEdge
}

"""All input for the `deleteGrouptableByNodeId` mutation."""
input DeleteGrouptableByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Grouptable` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteGrouptable` mutation."""
input DeleteGrouptableInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Student` mutation."""
type DeleteStudentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Student` that was deleted by this mutation."""
  student: Student
  deletedStudentNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Usertable` that is related to this `Student`."""
  user: Usertable

  """Reads a single `Citytable` that is related to this `Student`."""
  city: Citytable

  """An edge for our `Student`. May be used by Relay 1."""
  studentEdge(
    """The method to use when ordering `Student`."""
    orderBy: [StudentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): StudentsEdge
}

"""All input for the `deleteStudentByNodeId` mutation."""
input DeleteStudentByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Student` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteStudent` mutation."""
input DeleteStudentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `StudentToClass` mutation."""
type DeleteStudentToClassPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `StudentToClass` that was deleted by this mutation."""
  studentToClass: StudentToClass
  deletedStudentToClassNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Student` that is related to this `StudentToClass`."""
  student: Student

  """Reads a single `Classtable` that is related to this `StudentToClass`."""
  class: Classtable

  """Reads a single `Classtype` that is related to this `StudentToClass`."""
  classType: Classtype

  """An edge for our `StudentToClass`. May be used by Relay 1."""
  studentToClassEdge(
    """The method to use when ordering `StudentToClass`."""
    orderBy: [StudentToClassesOrderBy!] = [PRIMARY_KEY_ASC]
  ): StudentToClassesEdge
}

"""All input for the `deleteStudentToClassByNodeId` mutation."""
input DeleteStudentToClassByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `StudentToClass` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteStudentToClass` mutation."""
input DeleteStudentToClassInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  studentId: Int!
  classTypeId: Int!
}

"""The output of our delete `Teacher` mutation."""
type DeleteTeacherPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Teacher` that was deleted by this mutation."""
  teacher: Teacher
  deletedTeacherNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Usertable` that is related to this `Teacher`."""
  user: Usertable

  """Reads a single `Classtable` that is related to this `Teacher`."""
  class: Classtable

  """Reads a single `Citytable` that is related to this `Teacher`."""
  homeCity: Citytable

  """Reads a single `Classtype` that is related to this `Teacher`."""
  mainClassType: Classtype

  """An edge for our `Teacher`. May be used by Relay 1."""
  teacherEdge(
    """The method to use when ordering `Teacher`."""
    orderBy: [TeachersOrderBy!] = [PRIMARY_KEY_ASC]
  ): TeachersEdge
}

"""All input for the `deleteTeacherByNodeId` mutation."""
input DeleteTeacherByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Teacher` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteTeacher` mutation."""
input DeleteTeacherInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Usertable` mutation."""
type DeleteUsertablePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Usertable` that was deleted by this mutation."""
  usertable: Usertable
  deletedUsertableNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Citytable` that is related to this `Usertable`."""
  city: Citytable

  """Reads a single `Classtable` that is related to this `Usertable`."""
  signupInClass: Classtable

  """An edge for our `Usertable`. May be used by Relay 1."""
  usertableEdge(
    """The method to use when ordering `Usertable`."""
    orderBy: [UsertablesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsertablesEdge
}

"""All input for the `deleteUsertableByNodeId` mutation."""
input DeleteUsertableByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Usertable` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteUsertableById` mutation."""
input DeleteUsertableByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""All input for the `deleteUsertable` mutation."""
input DeleteUsertableInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  email: String!
}

"""The output of our `getClassesByIds` mutation."""
type GetClassesByIdsPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  results: [GetClassesByIdsRecord]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""The return type of our `getClassesByIds` mutation."""
type GetClassesByIdsRecord {
  classId: Int
  classTypeId: Int
  classYear: Int
  weekDay: String
  startTime: String
  classType: String
}

"""All input for the `getClassesByIds` mutation."""
input GetClassesByIdsInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  classIds: [Int]
}

"""The output of our `testfunc` mutation."""
type TestfuncPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  integer: Int

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `testfunc` mutation."""
input TestfuncInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  cityname: String
}

"""The output of our `updateYear` mutation."""
type UpdateYearPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  boolean: Boolean

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `updateYear` mutation."""
input UpdateYearInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""
The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.

#### Live Queries

Live query fields are differentiated by containing `(live)` at the end of their
description, they are added for each field in the `Query` type. When you
subscribe to a live query field, the selection set will be evaluated and sent to
the client, and then most things\* that would cause the output of the selection
set to change will trigger the selection set to be re-evaluated and the results
to be re-sent to the client.

_(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_

Live queries can be very expensive, so try and keep them small and focussed.

#### Events

Event fields will run their selection set when, and only when, the specified
server-side event occurs. This makes them a lot more efficient than Live
Queries, but it is still recommended that you keep payloads fairly small.
"""
type Subscription {
  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form. (live)
  """
  query: Query!

  """
  The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. (live)
  """
  nodeId: ID!

  """Fetches an object given its globally unique `ID`. (live)"""
  node(
    """The globally unique `ID`."""
    nodeId: ID!
  ): Node

  """Reads and enables pagination through a set of `Administrator`. (live)"""
  administrators(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Administrator`."""
    orderBy: [AdministratorsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AdministratorCondition
  ): AdministratorsConnection

  """Reads and enables pagination through a set of `Citytable`. (live)"""
  citytables(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Citytable`."""
    orderBy: [CitytablesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CitytableCondition
  ): CitytablesConnection

  """Reads and enables pagination through a set of `ClassOnline`. (live)"""
  classOnlines(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `ClassOnline`."""
    orderBy: [ClassOnlinesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ClassOnlineCondition
  ): ClassOnlinesConnection

  """Reads and enables pagination through a set of `Classtable`. (live)"""
  classtables(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Classtable`."""
    orderBy: [ClasstablesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ClasstableCondition
  ): ClasstablesConnection

  """Reads and enables pagination through a set of `Classtype`. (live)"""
  classtypes(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Classtype`."""
    orderBy: [ClasstypesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ClasstypeCondition
  ): ClasstypesConnection

  """Reads and enables pagination through a set of `ContentAdmin`. (live)"""
  contentAdmins(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `ContentAdmin`."""
    orderBy: [ContentAdminsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ContentAdminCondition
  ): ContentAdminsConnection

  """Reads and enables pagination through a set of `Coupon`. (live)"""
  coupons(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Coupon`."""
    orderBy: [CouponsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CouponCondition
  ): CouponsConnection

  """Reads and enables pagination through a set of `Grouptable`. (live)"""
  grouptables(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Grouptable`."""
    orderBy: [GrouptablesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GrouptableCondition
  ): GrouptablesConnection

  """Reads and enables pagination through a set of `Student`. (live)"""
  students(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Student`."""
    orderBy: [StudentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StudentCondition
  ): StudentsConnection

  """Reads and enables pagination through a set of `StudentToClass`. (live)"""
  studentToClasses(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `StudentToClass`."""
    orderBy: [StudentToClassesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StudentToClassCondition
  ): StudentToClassesConnection

  """Reads and enables pagination through a set of `Teacher`. (live)"""
  teachers(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Teacher`."""
    orderBy: [TeachersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TeacherCondition
  ): TeachersConnection

  """Reads and enables pagination through a set of `Usertable`. (live)"""
  usertables(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Usertable`."""
    orderBy: [UsertablesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UsertableCondition
  ): UsertablesConnection

  """ (live)"""
  administrator(id: Int!): Administrator

  """ (live)"""
  citytable(id: Int!): Citytable

  """ (live)"""
  classOnline(id: Int!): ClassOnline

  """ (live)"""
  classtable(id: Int!): Classtable

  """ (live)"""
  classtype(id: Int!): Classtype

  """ (live)"""
  classtypeByType(type: String!): Classtype

  """ (live)"""
  contentAdmin(id: Int!): ContentAdmin

  """ (live)"""
  coupon(id: Int!): Coupon

  """ (live)"""
  couponByCouponCode(couponCode: String!): Coupon

  """ (live)"""
  grouptable(id: Int!): Grouptable

  """ (live)"""
  student(id: Int!): Student

  """ (live)"""
  studentToClass(studentId: Int!, classTypeId: Int!): StudentToClass

  """ (live)"""
  teacher(id: Int!): Teacher

  """ (live)"""
  usertableById(id: Int!): Usertable

  """ (live)"""
  usertable(email: String!): Usertable

  """ (live)"""
  arrayDiff(array1: String, array2: String): String

  """Reads a single `Administrator` using its globally unique `ID`. (live)"""
  administratorByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Administrator`.
    """
    nodeId: ID!
  ): Administrator

  """Reads a single `Citytable` using its globally unique `ID`. (live)"""
  citytableByNodeId(
    """The globally unique `ID` to be used in selecting a single `Citytable`."""
    nodeId: ID!
  ): Citytable

  """Reads a single `ClassOnline` using its globally unique `ID`. (live)"""
  classOnlineByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `ClassOnline`.
    """
    nodeId: ID!
  ): ClassOnline

  """Reads a single `Classtable` using its globally unique `ID`. (live)"""
  classtableByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Classtable`.
    """
    nodeId: ID!
  ): Classtable

  """Reads a single `Classtype` using its globally unique `ID`. (live)"""
  classtypeByNodeId(
    """The globally unique `ID` to be used in selecting a single `Classtype`."""
    nodeId: ID!
  ): Classtype

  """Reads a single `ContentAdmin` using its globally unique `ID`. (live)"""
  contentAdminByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `ContentAdmin`.
    """
    nodeId: ID!
  ): ContentAdmin

  """Reads a single `Coupon` using its globally unique `ID`. (live)"""
  couponByNodeId(
    """The globally unique `ID` to be used in selecting a single `Coupon`."""
    nodeId: ID!
  ): Coupon

  """Reads a single `Grouptable` using its globally unique `ID`. (live)"""
  grouptableByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Grouptable`.
    """
    nodeId: ID!
  ): Grouptable

  """Reads a single `Student` using its globally unique `ID`. (live)"""
  studentByNodeId(
    """The globally unique `ID` to be used in selecting a single `Student`."""
    nodeId: ID!
  ): Student

  """Reads a single `StudentToClass` using its globally unique `ID`. (live)"""
  studentToClassByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `StudentToClass`.
    """
    nodeId: ID!
  ): StudentToClass

  """Reads a single `Teacher` using its globally unique `ID`. (live)"""
  teacherByNodeId(
    """The globally unique `ID` to be used in selecting a single `Teacher`."""
    nodeId: ID!
  ): Teacher

  """Reads a single `Usertable` using its globally unique `ID`. (live)"""
  usertableByNodeId(
    """The globally unique `ID` to be used in selecting a single `Usertable`."""
    nodeId: ID!
  ): Usertable
}
